# Generate all subsequences

!!! info "try"
    - index: 78
    - difficulty: medium
    - [link](https://leetcode.com/problems/subsets/description/)

## Description

Given an array of numbers, generate all subsequences.

## Example

```
input  = [1, 2, 3]
output = [] [1] [2] [3] [1, 2] [1, 3] [2, 3] [1, 2, 3] 
```

## Solution

??? "Approach 1"

    Recursive backtracking.

    ??? "Expand"

        $O(2^n)$ run time. $O(n^2)$ aux space used by the `partial`. Since the output is of size $O(2^n)$, with each subsequence of sizr $O(n)$, the space then would be $O(n \cdot 2^n)$. 

        ```kotlin
        fun generateSubsequences(nums: IntArray): List<List<Int>> {
          val out = mutableListOf<List<Int>>()
          helper(nums, 0, listOf(), out)
          return out
        }

        private fun helper(nums: IntArray, index: Int, partial: List<Int>, out: MutableList<List<Int>>) {
          if (index == nums.size) {
            out.add(partial)
            return
          }
          helper(nums, index + 1, partial + nums[index], out) // with nums[index]
          helper(nums, index + 1, partial, out)               // without nums[index]
        }
        ```

??? "Approach 2"

    Generate all bitmask from $[0, 2^n)$.

    ??? "Expand"

        All subsequences can be generated by asking the question "do I include you?" for each number. That is $2^n$ questions, which we can generate by iterating over $[0, 2^n)$.

        ```kotlin
        fun generateSubsequences(nums: IntArray): List<List<Int>> {
          val out = mutableListOf<List<Int>>()
          val subsequence = mutableListOf<Int>()

          for (mask in 0 until (1 shl nums.size)) {
            for (i in nums.indices) {
              if (mask and (1 shl i) != 0) {
                subsequence.add(nums[i])
              }
            }
            out.add(subsequence.toList())
            subsequence.clear()
          }

          return out
        }
        ```

## Unit tests

```kotlin
@Test
fun empty() {
  assertThat(generateSubsequences(intArrayOf())).containsExactlyInAnyOrder(listOf())
}

@Test
fun single() {
  assertThat(generateSubsequences(intArrayOf(5))).containsExactlyInAnyOrder(listOf(), listOf(5))
}

@Test
fun two() {
  assertThat(generateSubsequences(intArrayOf(1, 2))).containsExactlyInAnyOrder(
    listOf(),
    listOf(1),
    listOf(2),
    listOf(1, 2),
  )
}

@Test
fun three() {
  assertThat(generateSubsequences(intArrayOf(1, 2, 3))).containsExactlyInAnyOrder(
    listOf(),
    listOf(1),
    listOf(2),
    listOf(3),
    listOf(1, 2),
    listOf(1, 3),
    listOf(2, 3),
    listOf(1, 2, 3),
  )
}
```



